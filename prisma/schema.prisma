generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  CLIENT
  COMPANY
  ADMIN
}

enum FeatureStatus {
  BACKLOG
  UNDER_REVIEW
  IN_DEVELOPMENT
  DELIVERED
}

model User {
  id    String  @id @default(cuid())
  name  String?
  email String? @unique
  image String?
  // Auth local
  passwordHash String? @db.Text
  // RBAC
  role  Role    @default(CLIENT)

  // Multi-tenant
  workspaceId String?
  workspace   Workspace? @relation(fields: [workspaceId], references: [id])

  // External client company
  customerCompanyId String?
  customerCompany   CustomerCompany? @relation(fields: [customerCompanyId], references: [id])

  // next-auth
  accounts Account[]
  sessions Session[]

  // authored content
  features           Feature[]        @relation("FeatureAuthor")
  comments           FeatureComment[]
  votes              FeatureVote[] // <-- ADICIONE
  changelogsAuthored ChangelogEntry[] @relation("ChangelogAuthor") // <-- ADICIONE

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Workspace {
  id         String            @id @default(cuid())
  name       String
  slug       String            @unique
  // Se desabilitado, páginas públicas exigem login com usuário interno do workspace
  publicAccessEnabled Boolean   @default(true)
  // Marca se o onboarding inicial foi concluído
  onboardingCompleted Boolean   @default(false)
  users      User[]
  features   Feature[]
  changelogs ChangelogEntry[]
  scoring    ScoringConfig?
  customers  CustomerCompany[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CustomerCompany {
  id          String    @id @default(cuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  name            String
  size            String? // porte
  segment         String? // segmento
  strategicWeight Int      @default(1)
  // Receita mensal e nº de colaboradores para motor de score
  monthlyRevenue  Decimal?
  employees       Int?

  users        User[]
  interestedIn FeatureInterestedCompany[]
  votes        FeatureVote[] // <-- ADICIONE 

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([workspaceId])
}

model Feature {
  id          String    @id @default(cuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  title       String
  description String
  status      FeatureStatus @default(BACKLOG)

  impact Int? // 1..5 (visible to company/admin)
  effort Int? // 1..5 (visible to company/admin)
  score  Decimal @default(0)

  createdById String?
  createdBy   User?   @relation("FeatureAuthor", fields: [createdById], references: [id])

  votes         FeatureVote[]
  comments      FeatureComment[]
  interestedCos FeatureInterestedCompany[]
  changelogs    ChangelogEntry[]           @relation("ChangelogFeature") // <-- ADICIONE

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([workspaceId, status])
}

model FeatureVote {
  id                String  @id @default(cuid())
  featureId         String
  userId            String
  customerCompanyId String?

  feature         Feature          @relation(fields: [featureId], references: [id])
  user            User             @relation(fields: [userId], references: [id])
  customerCompany CustomerCompany? @relation(fields: [customerCompanyId], references: [id])

  createdAt DateTime @default(now())

  @@unique([featureId, userId])
  @@index([featureId, customerCompanyId])
}

model FeatureInterestedCompany {
  featureId         String
  customerCompanyId String

  feature         Feature         @relation(fields: [featureId], references: [id])
  customerCompany CustomerCompany @relation(fields: [customerCompanyId], references: [id])

  // optional metadata about the interest
  contact       String?
  internalAgent String?
  notes         String?

  createdAt DateTime @default(now())

  @@id([featureId, customerCompanyId])
}

model FeatureComment {
  id        String @id @default(cuid())
  featureId String
  userId    String
  content   String

  feature Feature @relation(fields: [featureId], references: [id])
  user    User    @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([featureId])
}

model ChangelogEntry {
  id          String    @id @default(cuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  title      String
  content    String
  releasedAt DateTime @default(now())
  featureId  String?
  feature    Feature? @relation("ChangelogFeature", fields: [featureId], references: [id]) // <-- AJUSTE

  assets ChangelogAsset[]

  createdById String?
  createdBy   User?   @relation("ChangelogAuthor", fields: [createdById], references: [id]) // <-- AJUSTE

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([workspaceId, releasedAt])
}

model ChangelogAsset {
  id          String         @id @default(cuid())
  changelogId String
  changelog   ChangelogEntry @relation(fields: [changelogId], references: [id])

  key      String // S3 key
  url      String
  size     Int?
  mimeType String?

  createdAt DateTime @default(now())
}

model ScoringConfig {
  id          String    @id @default(cuid())
  workspaceId String    @unique
  workspace   Workspace @relation(fields: [workspaceId], references: [id])

  // pesos: número de empresas pedindo, impacto, esforço (negativo), receita do cliente
  weightCompanies Int @default(5)
  weightImpact    Int @default(3)
  weightEffort    Int @default(-2)
  weightRevenue   Int @default(0)
  weightEmployees Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// next-auth standard tables
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
